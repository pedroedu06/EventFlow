"""
Arquivo: back/routs/codigo

Este arquivo contém exemplos em Python (Flask) e TypeScript (frontend) que implementam
um fluxo seguro de autenticação com JWT baseado em roles (user / admin).

Como funciona (resumo):
- O backend (Flask) valida credenciais e pesquisa a role do usuário no banco de dados.
- Gera um access token JWT (short-lived) e um refresh token (opcional - neste exemplo comentado).
- O access token é enviado ao cliente dentro de um cookie HttpOnly e Secure (não acessível via JS).
- O backend também retorna a role do usuário no corpo da resposta (somente role, sem o token).
- O frontend realiza a requisição com credentials: 'include' para enviar/receber cookies e
	redireciona para `/dashbordEvent` (admin) ou `/home` (user) com base na role.

OBS: Ajuste nomes de tables/fields conforme seu banco. Não exponha tokens no console do navegador.
"""

# --------------------
# BLOC 1 - Backend: Flask (Python)
# --------------------
# Requisitos do Python (instalar no seu venv):
# pip install Flask PyJWT passlib flask-cors python-dotenv
# (passlib para hashing de senhas, PyJWT para tokens)

from datetime import datetime, timedelta
import os
from functools import wraps
from flask import Flask, request, jsonify, make_response
import jwt

# ...existing code...

# Configurações essenciais — use variáveis de ambiente em produção
app = Flask(__name__)
app.config['SECRET_KEY'] = os.environ.get('SECRET_KEY', 'troque_por_um_segredo_forte')
app.config['JWT_ALGORITHM'] = 'HS256'
app.config['ACCESS_TOKEN_EXPIRES_MINUTES'] = 15  # tempo curto para reduzir risco

def generate_access_token(user_id: int, role: str) -> str:
		"""Gera um JWT com claims mínimos. Não coloque segredos sensíveis no payload."""
		payload = {
				'sub': user_id,
				'role': role,
				'iat': datetime.utcnow(),
				'exp': datetime.utcnow() + timedelta(minutes=app.config['ACCESS_TOKEN_EXPIRES_MINUTES'])
		}
		token = jwt.encode(payload, app.config['SECRET_KEY'], algorithm=app.config['JWT_ALGORITHM'])
		# PyJWT v2 retorna string; em versões antigas pode retornar bytes
		if isinstance(token, bytes):
				token = token.decode('utf-8')
		return token

def token_required(f):  
		"""Decorator para rotas protegidas que lê token do cookie HttpOnly."""
		@wraps(f)
		def decorated(*args, **kwargs):
				token = request.cookies.get('access_token')
				if not token:
						return jsonify({'message': 'Token ausente'}), 401
				try:
						data = jwt.decode(token, app.config['SECRET_KEY'], algorithms=[app.config['JWT_ALGORITHM']])
						request.user = {'id': data['sub'], 'role': data.get('role')}
				except jwt.ExpiredSignatureError:
						return jsonify({'message': 'Token expirado'}), 401
				except jwt.InvalidTokenError:
						return jsonify({'message': 'Token inválido'}), 401
				return f(*args, **kwargs)
		return decorated


@app.route('/login', methods=['POST'])
def login():
		"""Endpoint de login.

		Recebe JSON: { "email": "...", "password": "..." }
		1) Valida credenciais contra o banco (aqui ilustrado com pseudocódigo).
		2) Recupera a role do usuário ("admin" ou "user").
		3) Gera access token e o envia em cookie HttpOnly; retorna apenas a role no JSON.
		"""
		data = request.json
		if not data or not data.get('email') or not data.get('password'):
				return jsonify({'message': 'Credenciais inválidas'}), 400

		email = data['email']
		password = data['password']

		# --- Substitua o bloco abaixo pela lógica real de consulta ao seu banco ---
		# Exemplo de retorno simulado: (user_id, hashed_password, role)
		# user = query_db_get_user_by_email(email)
		# if not user or not verify_password(password, user.hashed_password):
		#     return jsonify({'message': 'Credenciais inválidas'}), 401
		# role = user.role
		# user_id = user.id

		# Para demo, vamos aceitar qualquer senha e alternar role por email
		if email.endswith('@admin.com'):
				role = 'admin'
				user_id = 1
		else:
				role = 'user'
				user_id = 2

		# Gera token
		access_token = generate_access_token(user_id, role)

		# Cria resposta com cookie HttpOnly e Secure
		resp = make_response(jsonify({'role': role}))
		# Cookies: HttpOnly (não acessível via JS), Secure (só via HTTPS), samesite=Lax
		# Em ambiente de desenvolvimento sem HTTPS, Secure pode impedir envio — ajuste localmente.
		secure_flag = True if os.environ.get('FLASK_ENV') == 'production' else False
		resp.set_cookie(
				'access_token', access_token,
				httponly=True,
				secure=secure_flag,
				samesite='Lax',
				max_age=app.config['ACCESS_TOKEN_EXPIRES_MINUTES'] * 60
		)

		return resp


@app.route('/protected-admin', methods=['GET'])
@token_required
def protected_admin():
		"""Exemplo de rota protegida que exige role 'admin'."""
		user = getattr(request, 'user', None)
		if not user or user.get('role') != 'admin':
				return jsonify({'message': 'Acesso negado: admin required'}), 403
		return jsonify({'message': f"Bem-vindo, admin {user.get('id')}"})


@app.route('/logout', methods=['POST'])
def logout():
		"""Remove o cookie do access token no cliente."""
		resp = make_response(jsonify({'message': 'Desconectado'}))
		resp.set_cookie('access_token', '', expires=0)
		return resp


# --------------------
# BLOC 2 - Frontend: TypeScript (exemplo com fetch ou React)
# --------------------
# Exemplo 1: função de login simples usando fetch. Não exponha tokens no console.

# file: src/service/auth.ts (exemplo)
"""
export async function login(email: string, password: string): Promise<void> {
	// Faz POST para /login; inclui cookies na requisição (credentials: 'include')
	const res = await fetch('http://localhost:5000/login', {
		method: 'POST',
		credentials: 'include', // necessário para receber cookie HttpOnly
		headers: {
			'Content-Type': 'application/json'
		},
		body: JSON.stringify({ email, password })
	})

	if (!res.ok) {
		// lidar com erro de autenticação
		const error = await res.json().catch(() => ({ message: 'Erro' }));
		throw new Error(error.message || 'Falha no login');
	}

	// O backend retorna apenas a role (por segurança não retorna o token no JSON)
	const body = await res.json();
	const role = body.role;

	// Redirecionamento baseado na role
	if (role === 'admin') {
		// Navegar para dashboard admin
		window.location.href = '/dashbordEvent';
	} else {
		// Navegar para home
		window.location.href = '/home';
	}
}
"""


# Exemplo 2: React + hook useLogin (TSX)
"""
import { useState } from 'react'

export function useLogin() {
	const [loading, setLoading] = useState(false)

	async function submit(email: string, password: string) {
		setLoading(true)
		try {
			const res = await fetch('http://localhost:5000/login', {
				method: 'POST',
				credentials: 'include',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({ email, password })
			})

			if (!res.ok) {
				const err = await res.json().catch(() => ({ message: 'Erro' }))
				throw new Error(err.message)
			}

			const data = await res.json()
			const role = data.role
			if (role === 'admin') window.location.href = '/dashbordEvent'
			else window.location.href = '/home'
		} finally {
			setLoading(false)
		}
	}

	return { submit, loading }
}
"""


# --------------------
# Notas de segurança (resumo e recomendações)
# --------------------
# 1) Sempre use HTTPS em produção para que cookies Secure funcionem e os tokens não sejam expostos.
# 2) Marque cookies como HttpOnly para que não possam ser acessados por JavaScript (mitiga XSS).
# 3) Evite armazenar tokens em localStorage/sessionStorage (vulnerável a XSS).
# 4) Use CSRF tokens ou SameSite=strict/lax quando aplicar mutações importantes. Para cookies de sessão,
#    considere proteção CSRF para endpoints state-changing.
# 5) Valide e sanitize todas as entradas (email, password) no backend para evitar injeção.
# 6) Armazene senhas com hashing forte (bcrypt via passlib recommended) e não em texto.
# 7) Use short-lived access tokens e refresh tokens armazenados com cuidado (ex.: refresh token HttpOnly em cookie
#    com rotação de refresh e blacklist no servidor se necessário).
# 8) Não logue tokens ou segredos no console do navegador nem no servidor. Use logs seguros com redaction.
# 9) Em CORS, permita apenas origens confiáveis e habilite credentials com cuidado.

# Exemplo mínimo de configuração CORS (usar flask-cors):
# from flask_cors import CORS
# CORS(app, supports_credentials=True, origins=['http://localhost:5173'])

# --------------------
# Como integrar com seu front existente:
# - Substitua as URLs (http://localhost:5000) pela URL real do backend.
# - Garanta que o front faça fetch com credentials: 'include' para enviar cookies.
# - Ajuste as rotas de redirecionamento para correspondê-las ao seu sistema de rotas do front.
# - Substitua a lógica de autenticação demo pelo seu código de consulta ao banco (ver `back/database`).

# Fim do arquivo

